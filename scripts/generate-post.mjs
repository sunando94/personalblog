import { GoogleGenerativeAI } from "@google/generative-ai";
import fs from "fs/promises";
import path from "path";
import dotenv from "dotenv";
import matter from "gray-matter";
import { fileURLToPath } from 'url';

// Helper to push to GitHub with dynamic branch support
export async function pushToGithub(content, filePath, options = {}) {
  const token = process.env.GITHUB_TOKEN;
  const repo = process.env.GITHUB_REPO || "sunando94/personalblog";
  const baseBranch = process.env.GITHUB_BRANCH || "dev";
  let targetBranch = options.branch || baseBranch;
  
  if (!token) {
    console.warn("Skipping GitHub push: GITHUB_TOKEN not found.");
    return false;
  }

  try {
    // 1. If autogen branch requested, create it first
    if (options.useAutoBranch) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      targetBranch = `auto-gen-post-${timestamp}`;
      console.log(`Creating autogenerated branch: ${targetBranch}...`);

      // Get Base SHA
      const getRefUrl = `https://api.github.com/repos/${repo}/git/refs/heads/${baseBranch}`;
      const refRes = await fetch(getRefUrl, { headers: { "Authorization": `token ${token}` } });
      const refData = await refRes.json();
      const baseSha = refData.object.sha;

      // Create New Ref
      const createRefUrl = `https://api.github.com/repos/${repo}/git/refs`;
      await fetch(createRefUrl, {
        method: "POST",
        headers: { "Authorization": `token ${token}`, "Content-Type": "application/json" },
        body: JSON.stringify({ ref: `refs/heads/${targetBranch}`, sha: baseSha })
      });
    }

    console.log(`Pushing to GitHub: ${repo} (${targetBranch})...`);
    
    // 2. Get the current file SHA if it exists (to update)
    const getUrl = `https://api.github.com/repos/${repo}/contents/${filePath}?ref=${targetBranch}`;
    const getRes = await fetch(getUrl, { headers: { "Authorization": `token ${token}` } });
    
    let sha;
    if (getRes.status === 200) {
      const fileData = await getRes.json();
      sha = fileData.sha;
    }

    // 3. Create or Update file
    const putUrl = `https://api.github.com/repos/${repo}/contents/${filePath}`;
    const putRes = await fetch(putUrl, {
      method: "PUT",
      headers: {
        "Authorization": `token ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        message: `Add/Update blog post: ${path.basename(filePath)}`,
        content: Buffer.from(content).toString("base64"),
        branch: targetBranch,
        sha: sha
      })
    });

    if (putRes.ok) {
      console.log(`Successfully pushed to GitHub on branch ${targetBranch}.`);
      
      // 4. Create Pull Request if it's a new branch
      let prUrl = null;
      if (options.useAutoBranch) {
        console.log(`Creating Pull Request for ${targetBranch}...`);
        const prRes = await fetch(`https://api.github.com/repos/${repo}/pulls`, {
          method: "POST",
          headers: { "Authorization": `token ${token}`, "Content-Type": "application/json" },
          body: JSON.stringify({
            title: `[AUTO-GEN] Blog Post: ${path.basename(filePath)}`,
            head: targetBranch,
            base: baseBranch,
            body: `This blog post was automatically generated via the MCP pipeline.\n\n**Topic:** ${path.basename(filePath)}\n**Branch:** ${targetBranch}\n\nPlease review and merge.`
          })
        });
        if (prRes.ok) {
          const prData = await prRes.json();
          prUrl = prData.html_url;
          console.log(`Pull Request created: ${prUrl}`);
        }
      }

      return { success: true, branch: targetBranch, prUrl };
    } else {
      const err = await putRes.text();
      throw new Error(`GitHub API failed: ${err}`);
    }
  } catch (e) {
    console.error("GitHub push failed:", e.message);
    return false;
  }
}

/**
 * Multi-Agent Pipeline for Blog Generation
 */
export async function generatePost(options = {}) {
  const {
    topic = process.env.TOPIC,
    apiKey = process.env.GEMINI_API_KEY,
    releaseDateInput = process.env.RELEASE_DATE || "now",
    contextInput = process.env.ADDITIONAL_CONTEXT || "",
    dryRun = false,
    mcpMode = false
  } = options;

  if (!topic || !apiKey) {
    throw new Error("Missing TOPIC or GEMINI_API_KEY.");
  }

  const genAI = new GoogleGenerativeAI(apiKey);
  const MODELS = ["gemini-3-flash-preview", "gemini-2.5-flash", "gemini-1.5-flash"];

  const generateWithFallback = async (prompt, stageName) => {
    for (const modelName of MODELS) {
      try {
        console.log(`[${stageName}] Attempting with ${modelName}...`);
        const model = genAI.getGenerativeModel({ model: modelName });
        const result = await model.generateContent(prompt);
        return result.response.text();
      } catch (e) {
        console.error(`[${stageName}] Failed with ${modelName}: ${e.message}`);
        if (modelName === MODELS[MODELS.length - 1]) throw e;
      }
    }
  };

  const normalizeDate = (dateStr) => {
    if (!dateStr) return null;
    const str = String(dateStr).trim();
    const ddmmyyyy = /^(\d{2})\/(\d{2})\/(\d{4})$/.exec(str);
    if (ddmmyyyy) return `${ddmmyyyy[3]}-${ddmmyyyy[2]}-${ddmmyyyy[1]}`;
    const yyyymmdd = /^\d{4}-\d{2}-\d{2}/.exec(str);
    if (yyyymmdd) return yyyymmdd[0];
    const d = new Date(str);
    return isNaN(d.getTime()) ? null : d.toISOString().split('T')[0];
  };

  const projectRoot = process.cwd();
  const postsDir = path.join(projectRoot, "_posts");
  await fs.mkdir(postsDir, { recursive: true });
  
  const existingFiles = await fs.readdir(postsDir);
  const existingDates = new Set();
  
  for (const file of existingFiles) {
    if (file.endsWith(".md")) {
      try {
        const content = await fs.readFile(path.join(postsDir, file), "utf-8");
        const { data } = matter(content);
        const rDate = normalizeDate(data.releaseDate || data.date);
        if (rDate) existingDates.add(rDate);
      } catch (e) {
        console.warn(`Could not parse date for ${file}: ${e.message}`);
      }
    }
  }

  let targetDate = releaseDateInput.toLowerCase() === "now" 
    ? new Date().toISOString().split('T')[0] 
    : normalizeDate(releaseDateInput) || new Date().toISOString().split('T')[0];

  let dateObj = new Date(targetDate);
  if (isNaN(dateObj.getTime())) dateObj = new Date();

  while (existingDates.has(dateObj.toISOString().split('T')[0])) {
    dateObj.setDate(dateObj.getDate() + 1);
  }
  const finalReleaseDate = dateObj.toISOString().split('T')[0];
  const today = new Date().toISOString().split('T')[0];

  let resolvedContext = "";
  if (contextInput) {
    if (contextInput.startsWith("http")) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const res = await fetch(contextInput, { signal: controller.signal });
        clearTimeout(timeoutId);
        resolvedContext = (await res.text()).replace(/<[^>]*>?/gm, ' ').substring(0, 8000);
      } catch (e) {
        resolvedContext = contextInput;
      }
    } else {
      const fullPath = path.join(projectRoot, contextInput);
      try {
        const stats = await fs.stat(fullPath);
        if (stats.isFile()) resolvedContext = await fs.readFile(fullPath, "utf-8");
        else resolvedContext = contextInput;
      } catch (e) {
        resolvedContext = contextInput;
      }
    }
  }

  const guidelines = await fs.readFile(path.join(projectRoot, ".agent/docs/blog_post_guidelines.md"), "utf-8");
  const slug = topic.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");

  const fillPrompt = async (name, data) => {
    let template = await fs.readFile(path.join(projectRoot, `mcp/prompts/${name}.md`), "utf-8");
    for (const [key, value] of Object.entries(data)) {
      template = template.replace(new RegExp(`{{${key}}}`, 'g'), value);
    }
    return template;
  };

  const unifiedPrompt = await fillPrompt('unified_post', {
    topic,
    guidelines,
    context: resolvedContext || "No additional context provided.",
    today,
    slug,
    finalReleaseDate: finalReleaseDate
  });

  let finalContent = await generateWithFallback(unifiedPrompt, "Unified Agent");
  finalContent = finalContent.trim();

  if (finalContent.startsWith("```markdown")) {
    finalContent = finalContent.substring(11, finalContent.length - 3).trim();
  } else if (finalContent.startsWith("```")) {
    finalContent = finalContent.substring(3, finalContent.length - 3).trim();
  }

  const fileName = `${slug}.md`;
  const filePath = path.join(postsDir, fileName);

  if (dryRun) {
    return { content: finalContent, releaseDate: finalReleaseDate, fileName };
  }

  try {
    await fs.writeFile(filePath, finalContent);
  } catch (e) {
    if (!e.code === 'EROFS') throw e;
  }

  const pushOptions = mcpMode ? { useAutoBranch: true } : {};
  let githubResult = null;
  if (process.env.GITHUB_TOKEN) {
    githubResult = await pushToGithub(finalContent, `_posts/${fileName}`, pushOptions);
  }

  return { 
    content: finalContent, 
    releaseDate: finalReleaseDate, 
    fileName,
    github: githubResult 
  };
}

if (import.meta.url === `file://${process.argv[1]}` || process.argv[1]?.endsWith('generate-post.mjs')) {
  generatePost().catch(err => {
    console.error("Pipeline failed:", err);
    process.exit(1);
  });
}
